import concurrent.futures
import os
from typing import List

from agentgymrl.training.common_entities.results import ToolSampleResult

from environment.calculation_environment import CalculatorState
from evaluation.verifiers.answer_verifier import is_correct_answer
from inference.model_exec.claude import Claude35HaikuExec
from training.rewards.exec_judge import JudgeExecutor

llm_judge = Claude35HaikuExec()

current_dir_of_this_file = os.path.dirname(os.path.abspath(__file__))

tool_judge = JudgeExecutor(
    model_exec=llm_judge,
    sys_msg_path=os.path.join(current_dir_of_this_file, "tool_judge.md"),
)

TOOL_WEIGHT = 0.80
CORRECTNESS_WEIGHT = 0.20

DEFAULT_FAILED_JUDGE_REWARD = 0.3  # Default reward for failed judge response


def process_single_conversation(result: ToolSampleResult) -> float:
    tool_use_resp = tool_judge.run_judge(state_to_prompt_string(state=result.state))

    correctness_score = (
        1.0
        if is_correct_answer(
            agent_answer=result.state.messages[-1]['content'],
            correct_answer=result.answer,
        )
        else 0.0
    )

    reward = (
        TOOL_WEIGHT * (tool_use_resp.score if tool_use_resp else DEFAULT_FAILED_JUDGE_REWARD)
        + CORRECTNESS_WEIGHT * correctness_score
    )

    reward = max(0.0, min(1.0, reward))

    return reward

def state_to_prompt_string(state: CalculatorState, include_sys_msg: bool=False) -> str:
    msg_strs = []
    for msg in state.messages:
        if msg['role'] == "system" and not include_sys_msg:
            continue
        msg_strs.append(f"{msg['role'].capitalize()}:\n{msg['content']}\n\n")

    return "".join(msg_strs)

def calculate_reward(tool_sample_results: List[ToolSampleResult]) -> List[float]:
    """
    Calculate rewards for each conversation-answer pair in parallel.

    Args:
        tool_sample_results: List of results generated by the tool calling agent

    Returns:
        List of reward values between 0.0 and 1.0
    """
    assert abs(TOOL_WEIGHT + CORRECTNESS_WEIGHT - 1.0) < 1e-6, "Weights must sum to 1.0"

    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        rewards = list(executor.map(process_single_conversation, tool_sample_results))

    return rewards
